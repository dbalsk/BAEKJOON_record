## [정렬]
**✔ 정렬의 종류** 
- **선택 정렬**
  - 첫번째 인덱스부터 시작하여 뒤의 모든 인덱스와 비교하고 **최솟값을 찾아서(선택하여)** 바꾸고 이를 반복.
  - 시간복잡도: 평균/최선/최악 모두 **O(n^2)** (낮은 성능의 알고리즘)
- **카운팅 정렬 (계수 정렬)**
  - (값을 비교하면서 정렬하는 것이 아닌) 각 **값**을 **counting 배열의 인덱스**로 두고 **값의 빈도수**를 세어 해당 인덱스에 넣어주는 방법  
    ex) arr[0]=7, arr[3]=7 -> counting[7]을 2올려줌
  - 시간복잡도: 평균/최선/최악 모두 O(n+k)  (k는 최댓값)
   > 대표적 빠른 정렬알고리즘인 퀵/힙/합병 정렬이 nlogn이기에 상당히 빠른 성능. 하지만 배열(counting) 하나를 더 추가해야되기에 **수의 범위가 크면** 메모리 낭비가 심하여 주로 사용x  
   > ex) 10개의 배열 정렬인데 수의 범위 0~1억 -> counting 배열의 길이가 1억 -> 메모리낭비가 큼
  - [Stranger's LAB - 카운팅정렬](https://st-lab.tistory.com/104)


**✔ 정렬 메소드**   
- **Arrays.sort()**
  - 배열의 크기가 큰 경우 **dual-pivot Quicksort 알고리즘**
  - 크기가 작은 배열(32이하)일 경우 **Insertion Sort(삽입정렬) 알고리즘** 사용 (효율적이기에)
  - 객체배열일 경우 **Timsort 알고리즘** 사용
  - 시간복잡도: 평균 **O(nlogn)** (최악은 3가지 알고리즘 중 어떤 것이냐에 따라 달라짐) 
  - 사용방법: Arrays.sort(arr) / Arrays.sort(arr, 판단기준) (보통 메소드나 comparator로 판단기준 설정)
- **Collections.sort()**
  - Timsort (합병정렬 최악 + 삽입정렬 최선) 알고리즘 
  - 시간복잡도: 평균/최선/최악 모두 **O(nlogn)**
  - 사용방법: Collections.sort(list)   
    주의) 배열을 **리스트** 계열로 사용해야함 (ArrayList, LinkedList..) 
</br>

**(복습) [2750 - 수 정렬하기](https://www.acmicpc.net/problem/2750)**      
- 3가지 방법으로 풀이가능 -> 선택정렬 / Arrays.sort() / 카운팅 정렬
- 선택정렬: 이중반복문으로 선택한 인덱스를 다른 인덱스들과 비교 후 더 작다면 temp로 계속해서 위치 변경 (작다면 계쏙 뒤로감)  

**(복습) [2751 - 수 정렬하기2](https://www.acmicpc.net/problem/2751)**      
- 2750과 문제는 동일하나 데이터와 수의 범위를 늘려놓음. Arrays.sort()의 저격데이터를 넣어놨기에 다른 방법으로 풀어야함. 
- 2가지 방법으로 풀이가능 -> 카운팅 정렬 / Collections.sort()
