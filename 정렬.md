## [정렬]
**✔ 정렬의 종류** 
- **선택 정렬**
  - 첫번째 인덱스부터 선택하여 뒤의 모든 인덱스와 비교하고 이를 반복.
  - 시간복잡도: O(n^2) (낮은 성능의 알고리즘)
- **카운팅 정렬 (계수 정렬)**
  - (값을 비교하면서 정렬하는 것이 아닌) 각 **값**을 **counting 배열의 인덱스**로 두고 **값의 빈도수**를 세어 해당 인덱스에 넣어주는 방법  
    ex) arr[0]=7, arr[3]=7 -> counting[7]을 2올려줌
  - 시간복잡도: O(n)
   > 대표적 빠른 정렬알고리즘인 퀵/힙/합병 정렬이 nlogn이기에 상당히 빠른 성능. 하지만 배열(counting) 하나를 더 추가해야되기에 **수의 범위가 크면** 메모리 낭비가 심하여 주로 사용x  
   > ex) 10개의 배열 정렬인데 수의 범위 0~1억 -> counting 배열의 길이가 1억 -> 메모리낭비가 큼
  - [Stranger's LAB - 카운팅정렬](https://st-lab.tistory.com/104)
   
**✔ 정렬 메소드**  
- **Arrays.sort()**
  - 자바의 기본 메소드 / dual-pivot Quicksort 알고리즘
  - 시간복잡도: O(nlogn) (최악일 경우 O(n^2))
  - 사용방법: Arrays.sort(arr) / Arrays.sort(arr, 판단기준) (보통 메소드나 comparator로 판단기준 설정)

</br>

**(복습) [2750 - 수 정렬하기](https://www.acmicpc.net/problem/2750)**      
- 3가지 방법으로 풀이가능 -> 선택정렬 / Arrays.sort() / 카운팅 정렬
- 선택정렬: 이중반복문으로 선택한 인덱스를 다른 인덱스들과 비교 후 더 작다면 temp로 위치 변경  
- Arrays.sort(): 
